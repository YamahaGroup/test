const cds = require('../../../')
const { toODataResult } = require('../utils/result')
const querystring = require('node:querystring')
const { getPageSize } = require('../../_runtime/common/generic/paging')
const { handleStreamProperties } = require('../../_runtime/common/utils/streamProp')

const { getKeysFromPath } = require('../utils')

// REVISIT: move to or rewrite in libx/odata
const metaInfo = require('../../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')

const _getCount = result =>
  Array.isArray(result)
    ? result.reduce((acc, val) => {
        return acc + ((val && (val.$count || val._counted_)) || (val[0] && (val[0].$count || val[0]._counted_))) || 0
      }, 0)
    : result.$count || result._counted_ || 0

const _calculateNextLink = (req, result) => {
  const $skiptoken = _calculateSkiptoken(req, result)
  if ($skiptoken) {
    const queryParamsWithSkipToken = { ...req.http.req.query, $skiptoken }
    // REVISIT: slice replaces leading '/'. Always starts with '/'?
    result.$nextLink =
      req.http.req.path.slice(1) +
      '?' +
      querystring.stringify(queryParamsWithSkipToken, '&', '=', { encodeURIComponent: e => e })
  }
}

const _calculateSkiptoken = (req, result) => {
  const limit = Array.isArray(req.query) ? getPageSize(req.query[0]._target).max : req.query.SELECT.limit?.rows?.val
  const top = parseInt(req.http.req.query.$top)
  if (limit === result.length && limit !== top) {
    const token = req.http.req.query.$skiptoken
    if (cds.env.query.limit.reliablePaging && _reliablePagingPossible(req)) {
      const decoded = token && JSON.parse(Buffer.from(token, 'base64').toString())
      const skipToken = {
        r: (decoded?.r || 0) + limit,
        c: req.query.SELECT.orderBy.map(o => ({
          a: o.sort ? o.sort === 'asc' : true,
          k: o.ref[0],
          v: result[result.length - 1][o.ref[0]]
        }))
      }

      if (limit + (decoded?.r || 0) !== top) {
        return Buffer.from(JSON.stringify(skipToken)).toString('base64')
      }
    } else {
      return (token ? parseInt(token) : 0) + limit
    }
  }
}

const _reliablePagingPossible = req => {
  if (req.target._isDraftEnabled) return false
  if (cds.context?.http.req.query.$apply) return false
  if (req.query.SELECT.limit.offset?.val ?? req.query.SELECT.limit.offset > 0) return false
  if (req.query.SELECT.orderBy?.some(o => !o.ref)) return false
  return (
    !req.query.SELECT.columns ||
    req.query.SELECT.columns.some(c => c === '*' || c.ref?.[0] === '*') ||
    req.query.SELECT.orderBy?.every(o => req.query.SELECT.columns?.some(c => o.ref[0] === c.ref?.[0]))
  )
}

module.exports = srv =>
  function read(req, res, next) {
    if (req._preferReturn) {
      const message = `The 'return' preference is not allowed in ${req.method} requests`
      return res.status(400).json({ error: { code: '400', message } })
    }

    const { _query: query } = req

    // mainly for @odata.context
    const info = metaInfo(query, 'READ', srv, {}, req, false)

    const lastPathElement = req.path.split('/').slice(-1)[0]

    handleStreamProperties(query.target, query.SELECT.columns, srv.model)

    // we need the cds request, so we can access the modified query, which is cloned due to lean-draft, so we need to use dispatch here and pass a cds req
    const cdsReq = new cds.Request({ query })
    // for read and delete, we provide keys in req.data
    cdsReq.data = getKeysFromPath(query.SELECT.from, srv)

    // REVISIT: what is this for? some tests fail without it... we should find a better solution!
    Object.defineProperty(query.SELECT, '_4odata', { value: true })

    return srv
      .dispatch(cdsReq)
      .then(result => {
        if (result == null && query._target._isSingleton && query._target['@odata.singleton.nullable'])
          return res.sendStatus(204)

        if (lastPathElement === '$count') {
          result = _getCount(result)
          return res.send(result.toString())
        } else if (lastPathElement === '$value' && query._propertyAccess) {
          return res.send(result[query._propertyAccess].toString())
        }

        if (query._propertyAccess && result[query._propertyAccess] === null) return res.sendStatus(204)

        if (result == null) return res.status(404).json({ error: { code: '404', message: 'Not Found' } })

        if (info.metadata.isCollection && !result.$nextLink) _calculateNextLink(cdsReq, result)
        result = toODataResult(result, info)

        // Express interprets numbers as HTTP status codes
        res.send(typeof result === 'number' ? result.toString() : result)
      })
      .catch(next)
  }
