const cds = require('../../../')
const { INSERT, UPDATE } = cds.ql

const { toODataResult } = require('../utils/result')
const { odataError, getKeysFromPath } = require('../utils')

const { deepCopy } = require('../../_runtime/common/utils/copy')

// REVISIT: move to or rewrite in libx/odata
const { readAfterWrite } = require('../../_runtime/cds-services/adapter/odata-v4/utils/readAfterWrite')
const metaInfo = require('../../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')

const _isUpsertAllowed = ({ target, data, event }) => {
  return (
    !(cds.env.runtime && cds.env.runtime.allow_upsert === false) &&
    !(target && target._isDraftEnabled && (!cds.env.fiori.lean_draft || (!data.IsActiveEntity && event === 'PATCH')))
  )
}

const _isNavigationWithKeyInParent = (keys, data, pathExpression, model) => {
  // keys not in data
  if (keys && Object.keys(keys).some(key => key in data)) {
    return false
  }

  const nav = pathExpression.ref && pathExpression.ref.length !== 0 && pathExpression.ref[1]
  const parent = pathExpression.ref && pathExpression.ref[0].id

  // not a navigation
  if (!parent || !nav) {
    return false
  }

  const navID = typeof nav === 'string' ? nav : nav.id
  const navElement = model.definitions[parent].elements[navID]

  // not a containment
  if (!navElement._isContained) {
    return false
  }

  const where = pathExpression.ref[0].where
  return parent && navElement && where
}

const _hasEtag = target => target._etag

module.exports = srv =>
  function update(req, res, next) {
    const { _query: query } = req

    const {
      SELECT: { one, from }
    } = query

    // REVISIT: patch on collection is allowed in odata 4.01
    if (!one) {
      return res.status(405).json(odataError('405', `Method ${req.method} not allowed for ENTITY.COLLECTION`))
    }

    // REVISIT: better
    const isPropertyAccess = !!query._propertyAccess

    const updateData = isPropertyAccess ? { [query._propertyAccess]: req.body.value } : deepCopy(req.body)

    if (!isPropertyAccess) {
      // add keys from url into payload (overwriting if already present)
      Object.assign(updateData, getKeysFromPath(from, srv))

      // assert complex
      const assertOptions = { filter: true, http: { req }, mandatories: req.method === 'PUT' || undefined }
      const errs = cds.assert(updateData, query.target, assertOptions)
      if (errs) {
        if (errs.length === 1) throw errs[0]
        throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
      }
    } else {
      // TODO: assert primitive
    }

    const updateQuery = UPDATE.entity(from).with(updateData)

    // we need the cds request, so we can access req._.readAfterWrite
    const cdsReq = new cds.Request({ query: updateQuery })

    // REVISIT: adjust in getter?
    if (req.method === 'PUT') cdsReq.method = 'PUT'

    // rewrite event for draft-enabled entities
    if (query.target._isDraftEnabled) cdsReq.event = 'PATCH'

    return srv
      .dispatch(cdsReq)
      .then(async result => {
        if (!(isPropertyAccess && !_hasEtag(query.target)) && cdsReq._.readAfterWrite) {
          // TODO see if in old odata impl for other checks that should happen
          result = await readAfterWrite(cdsReq, srv, { operation: { result } })
        }

        // REVISIT: metaInfo needs original query in case of property access, but why?
        const info = metaInfo(isPropertyAccess ? query : updateQuery, 'UPDATE', srv, result, req)

        if (
          result == null ||
          req._preferReturn === 'minimal' ||
          (isPropertyAccess && result[query._propertyAccess] == null) ||
          info.metadata.isStream
        )
          return res.sendStatus(204)

        result = toODataResult(result, info)
        return res.send(result)
      })
      .catch(async e => {
        // UPSERT
        const is404 = e.code === 404 || e.status === 404 || e.statusCode === 404
        if (
          is404 &&
          !isPropertyAccess &&
          _isUpsertAllowed({ target: query.target, data: updateData, event: req.method })
        ) {
          // PUT / PATCH with if-match header means "only if already exists" -> no insert if it does not
          if (req.headers['if-match']) throw Object.assign(new Error('412'), { statusCode: 412 })

          // check only works with req.body and not with updateDate
          if (_isNavigationWithKeyInParent(query.target.keys, req.body, from, srv.model)) {
            // REVISIT: better error message
            return res.status(422).json(odataError('422', `Unprocessable Entity`))
          }

          // REVISIT:
          //   can we somehow "replay" the request with POST?
          //   or should we call the create handler directly?

          const insertData = deepCopy(req.body)

          // add keys from url into payload (overwriting if already present)
          Object.assign(insertData, getKeysFromPath(from, srv))

          // assert payload
          const assertOptions = { filter: true, http: { req }, mandatories: true }
          const errs = cds.assert(insertData, query.target, assertOptions)
          if (errs) {
            if (errs.length === 1) throw errs[0]
            throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
          }

          // REVISIT: up_XX needs to be looked up -> composition of aspect
          const insertQuery = INSERT.into(from).entries(insertData)
          const cdsReq = new cds.Request({ query: insertQuery })
          let result = await srv.dispatch(cdsReq)

          if (cdsReq._.readAfterWrite) {
            // TODO see if in old odata impl for other checks that should happen
            result = await readAfterWrite(cdsReq, srv, { operation: { result } })
          }

          const info = metaInfo(insertQuery, 'CREATE', srv, result, req)
          result = toODataResult(result, info)
          return res.status(201).send(result)
        }
        throw e
      })
      .catch(next)
  }
