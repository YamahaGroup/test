const cds = require('../../../')
const { INSERT } = cds.ql

const { toODataResult } = require('../utils/result')
const { odataError, getKeysFromPath } = require('../utils')

const { deepCopy } = require('../../_runtime/common/utils/copy')

// REVISIT: move to or rewrite in libx/odata
const { readAfterWrite } = require('../../_runtime/cds-services/adapter/odata-v4/utils/readAfterWrite')
const metaInfo = require('../../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')

const _calculateLocationHeader = (target, srv, result) => {
  const targetName = target.name.replace(`${srv.name}.`, '')

  const keyValuePairs = Object.keys(target.keys).reduce((acc, key) => {
    acc[key] = result[key]
    return acc
  }, {})

  let keys
  const entries = Object.entries(keyValuePairs)
  if (entries.length === 1) {
    keys = entries[0][1]
  } else {
    keys = entries.map(([key, value]) => `${key}=${value}`).join(',')
  }

  return `${targetName}(${keys})`
}

module.exports = srv =>
  function create(req, res, next) {
    const { _query: query } = req

    const {
      SELECT: { one, from }
    } = query

    if (one) {
      const singleton = query.target._isSingleton
      const error = odataError('405', `Method ${req.method} not allowed for ${singleton ? 'SINGLETON' : 'ENTITY'}`)
      return res.status(405).json(error)
    }

    const data = deepCopy(req.body)

    // add keys from url into payload (overwriting if already present)
    Object.assign(data, getKeysFromPath(from, srv))

    // assert payload
    const assertOptions = { filter: true, http: { req }, mandatories: true }
    const errs = cds.assert(data, query.target, assertOptions)
    if (errs) {
      if (errs.length === 1) throw errs[0]
      throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
    }

    const insertQuery = INSERT.into(from).entries(data)

    // we need the cds request, so we can access req._.readAfterWrite
    const cdsReq = new cds.Request({ query: insertQuery })

    // rewrite event for draft-enabled entities
    if (query.target._isDraftEnabled) cdsReq.event = 'NEW'

    return srv
      .dispatch(cdsReq)
      .then(async result => {
        if (cdsReq._.readAfterWrite) {
          // TODO see if in old odata impl for other checks that should happen
          result = await readAfterWrite(cdsReq, srv, { operation: { result } })
        }

        if (result == null || req._preferReturn === 'minimal') return res.sendStatus(204)

        const location = _calculateLocationHeader(cdsReq.target, srv, result)
        const info = metaInfo(insertQuery, 'CREATE', srv, result, req)
        result = toODataResult(result, info)
        res.set('location', location).status(201).send(result)
      })
      .catch(next)
  }
