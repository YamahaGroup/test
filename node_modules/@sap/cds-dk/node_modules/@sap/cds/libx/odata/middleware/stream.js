const cds = require('../../../')
const { Readable } = require('node:stream')
const getError = require('../../_runtime/common/error')
const { getTransition } = require('../../_runtime/common/utils/resolveView')
const LOG = cds.log('odata')
const { getKeysFromPath } = require('../utils')

const _resolveContentProperty = (target, annotName, resolvedProp) => {
  if (target.elements[resolvedProp]) {
    return resolvedProp
  }
  LOG._warn &&
    LOG.warn(
      `"${annotName}" in entity "${target.name}" points to property "${resolvedProp}" which was renamed or is not part of the projection. You must update the annotation value.`
    )
  const mapping = getTransition(target, cds.db).mapping
  const key = [...mapping.entries()].find(({ 1: val }) => val.ref[0] === resolvedProp)
  return key?.length && key[0]
}

const isStream = query => {
  const { _propertyAccess, target } = query
  const element = target.elements[_propertyAccess]
  return Boolean(element?.['@Core.MediaType'])
}

const isStreamByDollarValue = (query, previous, last) => {
  return query.SELECT.one && last === '$value' && !(previous in query.target.elements)
}

const _addMetadataProperty = (query, property, annotName, odataName) => {
  if (typeof property[annotName] === 'object') {
    const contentProperty = _resolveContentProperty(
      query.target,
      annotName,
      property[annotName]['='].replaceAll(/\./g, '_')
    )
    query.target.elements[contentProperty]
      ? query.SELECT.columns.push({ ref: [contentProperty], as: odataName })
      : LOG._warn &&
        LOG.warn(`"${annotName.split('.')[1]}" ${contentProperty} not found in entity "${query.target.name}".`)
  } else {
    query.SELECT.columns.push({ val: property[annotName], as: odataName })
  }
}

const addStreamMetadata = query => {
  // new odata parser sets streaming property in SELECT.from
  const ref = query.SELECT.columns?.[0].ref || query.SELECT.from.ref
  const propertyName = ref[ref.length - 1]
  let mediaTypeProperty
  for (let key in query.target.elements) {
    const val = query.target.elements[key]
    if (val['@Core.MediaType'] && val.name === propertyName) {
      mediaTypeProperty = val
      break
    }
  }

  _addMetadataProperty(query, mediaTypeProperty, '@Core.MediaType', '$mediaContentType')

  if (mediaTypeProperty['@Core.ContentDisposition.Filename']) {
    _addMetadataProperty(
      query,
      mediaTypeProperty,
      '@Core.ContentDisposition.Filename',
      '$mediaContentDispositionFilename'
    )
  }

  if (mediaTypeProperty['@Core.ContentDisposition.Type']) {
    query.SELECT.columns.push({
      val: mediaTypeProperty['@Core.ContentDisposition.Type'],
      as: '$mediaContentDispositionType'
    })
  }
}

const validateStream = (req, res, result) => {
  // REVISIT: compat, should actually be treated as object
  if (!Array.isArray(result)) result = [result]

  // Reading one entity or a property of it should yield only a result length of one.
  if (result.length === 0 || result[0] === undefined) {
    if (req.headers['if-none-match']) {
      // TODO this should probably end the request?
      res.status(304)
      return
    }
    throw getError(404)
  }

  if (result.length > 1) throw getError(400)

  if (result[0] === null) return null

  result = result[0]

  const headers = req.headers
  const contentType = result.$mediaContentType

  if (!headers?.accept || !contentType) return

  if (
    !headers.accept.includes('*/*') &&
    !headers.accept.includes(contentType) &&
    !headers.accept.includes(contentType.split('/')[0] + '/*')
  ) {
    throw Object.assign(new Error(`Content type "${contentType}" not listed in accept header "${headers.accept}".`), {
      statusCode: 406
    })
  }
}

const _ensureStream = stream => {
  if (stream === null) return null
  // temp workaround for url streaming
  const stream_ = new Readable()
  stream_.push(stream)
  stream_.push(null)
  return stream_
}

const normalizeStream = (result, propertyName, lastPathElement, target) => {
  let readable = result
  if (typeof result === 'object') {
    if (propertyName && result[propertyName] !== undefined) {
      readable = result[propertyName]
    }
    // implicit streaming
    else if (lastPathElement === '$value') {
      const property = Object.values(target.elements).find(
        el => el.type === 'cds.LargeBinary' && result[el.name] !== undefined
      )
      readable = property && result[property.name]
    }
    // result.value can be obtained from custom handlers
    else if (result.value !== undefined) {
      readable = result.value
    }
  }

  if (!(readable instanceof Readable)) {
    readable = _ensureStream(readable)
  }

  if (readable) {
    readable.on('error', () => {
      readable.removeAllListeners('error')
      // readable.destroy() does not end stream in node 10 and 12
      readable.push(null)
    })
  }

  return readable
}

const setStreamingHeaders = (result, res) => {
  // backwards compatibility for content-type in stream
  if (result['$mediaContentType']) res.setHeader('Content-Type', result.$mediaContentType)
  else if (result['*@odata.mediaContentType']) res.setHeader('Content-Type', result['*@odata.mediaContentType'])
  else res.setHeader('Content-Type', 'application/octet-stream')

  if ('$mediaContentDispositionFilename' in result) {
    const cdt = result.$mediaContentDispositionType || 'attachment'
    res.setHeader(
      'Content-Disposition',
      `${cdt}; filename="${encodeURIComponent(result.$mediaContentDispositionFilename)}"`
    )
  }
}

const stream = srv =>
  function streamHandler(req, res, next) {
    const { _query: query } = req

    const [previous, lastPathElement] = req.path.split('/').slice(-2)
    const _isStreamByDollarValue = isStreamByDollarValue(query, previous, lastPathElement)

    if (_isStreamByDollarValue) {
      for (const k in query.target.elements) {
        if (query.target.elements[k]['@Core.MediaType']) {
          query.SELECT.columns = [{ ref: [k] }]
          query._propertyAccess = k
          break
        }
      }
    }

    query.SELECT.columns ??= ['*']

    const _isStream = isStream(query) || _isStreamByDollarValue

    if (!_isStream) {
      return next(null, req, res)
    }

    if (!query.target['@cds.persistence.skip']) addStreamMetadata(query)

    // we need the cds request, so we can access the modified query, which is cloned due to lean-draft, so we need to use dispatch here and pass a cds req
    const cdsReq = new cds.Request({ query })
    // for read and delete, we provide keys in req.data
    cdsReq.data = getKeysFromPath(query.SELECT.from, srv)

    // REVISIT: what is this for? some tests fail without it... we should find a better solution!
    Object.defineProperty(query.SELECT, '_4odata', { value: true })

    return srv.tx(() => {
      return srv
        .dispatch(cdsReq)
        .then(async result => {
          validateStream(req, res, result)

          const stream = normalizeStream(result, query._propertyAccess, lastPathElement, query.target)
          if (stream === null) {
            if (req.headers['if-none-match']) {
              return res.status(304).json({})
            }
            return res.status(204).json({})
          }

          setStreamingHeaders(result, res)

          return new Promise((resolve, reject) => {
            stream.pipe(res)
            stream.on('end', () => resolve(result))
            stream.once('error', reject)
          })
        })
        .catch(next)
    })
  }

module.exports = {
  stream,
  isStream
}
