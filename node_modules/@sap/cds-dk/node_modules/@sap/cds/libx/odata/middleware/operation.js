const cds = require('../../../')

const { toODataResult } = require('../utils/result')
const { cds2edm } = require('../utils')

const { deepCopy } = require('../../_runtime/common/utils/copy')

// REVISIT: move to or rewrite in libx/odata
const metaInfo = require('../../_runtime/cds-services/adapter/odata-v4/utils/metaInfo')

module.exports = srv => (req, res, next) => {
  let { operation, args } = req._query.SELECT.from.ref.slice(-1)[0]
  if (!operation) return next() //> create or read

  // unbound vs. bound
  let entity
  if (srv.model.definitions[operation]) {
    operation = srv.model.definitions[operation]
  } else {
    req._query.SELECT.from.ref.pop()
    // TODO: this does not work when navigating to the entity
    const lastRef = req._query.SELECT.from.ref.slice(-1)[0]
    entity = lastRef.id || lastRef
    entity = srv.model.definitions[entity]
    operation = entity.actions[operation]
  }

  const data = args || deepCopy(req.body)

  // assert payload
  const assertOptions = { filter: true, http: { req }, mandatories: true }
  const errs = cds.assert(data, operation, assertOptions)
  if (errs) {
    if (errs.length === 1) throw errs[0]
    throw Object.assign(new Error('MULTIPLE_ERRORS'), { statusCode: 400, details: errs })
  }

  // REVISIT: when is operation.name actually prefixed with the service name?
  const event = operation.name.replace(`${srv.name}.`, '')

  // TODO: params
  const cdsReq = new cds.Request({ query: entity ? req._query : undefined, event, data, params: [] })

  srv
    .dispatch(cdsReq)
    .then(result => {
      // REVISIT:  result === undefined valid for modelled return type?
      if (!operation.returns || result === undefined) return res.sendStatus(204)

      if (operation.returns._type?.match?.(/^cds\./)) {
        // TODO: check result type
        return res.json({
          '@odata.context': `${entity ? '../' : ''}$metadata#${cds2edm[operation.returns._type]}`,
          value: result
        })
      }

      const assertOptions = { mandatories: true } //> TODO: more needed?
      // TODO: error targets are not correct if return type is "many X"
      const assertDefinition = operation.returns.items || operation.returns
      const errs = cds.assert(result, assertDefinition, assertOptions)
      if (errs) {
        // TODO: proper error handling
      }

      const info = metaInfo(req._query, event, srv, result, req)
      // FIXME: info.metadata.isCollection is incorrect for draftActivate
      if (event === 'draftActivate') info.metadata.isCollection = false
      result = toODataResult(result, info)

      // TODO: toODataResult() doesn't seem to handle this case
      if (entity && !result['@odata.context'].match(/^\.\.\//))
        result['@odata.context'] = '../' + result['@odata.context']

      res.json(result)
    })
    .catch(next)
}
